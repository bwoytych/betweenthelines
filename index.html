<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Between the Lines — Fantasy History (Embedded)</title>
<link rel="stylesheet" href="style.css">
</head>
<body>
<header>
  <h1>Between the Lines — Fantasy History</h1>
  <p class="subtitle">Standings, H2H, interactive bracket — data from embedded workbook</p>
</header>

<nav id="nav"></nav>

<main class="main">
  <section class="card" id="standings-card">
    <h2 id="season-title">Loading...</h2>
    <div id="standings-area"></div>
  </section>

  <section class="card" id="h2h-card">
    <h2>Head-to-Head</h2>
    <div id="h2h-area"></div>
  </section>

  <section class="card" id="bracket-card">
    <h2>Playoff Bracket (editable)</h2>
    <div id="bracket-area"></div>
    <div style="margin-top:8px"><button id="reset-bracket">Reset Bracket</button></div>
  </section>

  <section class="card" id="alltime-card">
    <h2>All-Time</h2>
    <div id="alltime-area"></div>
  </section>
</main>

<footer class="footer">Data source: embedded Excel snapshot. Bracket edits stored locally.</footer>

<script>
async function loadEmbeddedData(){
  const res = await fetch('data.json');
  const obj = await res.json();
  return obj;
}

function findStandingsHeader(rows){
  for(let r=0; r<Math.min(10, rows.length); r++){ 
    const lower = rows[r].map(c=>String(c).toLowerCase());
    if(lower.some(c=>c.includes('team')) && lower.some(c=>c.includes('win'))) return r;
  }
  return -1;
}

function extractStandings(rows){
  const hdr = findStandingsHeader(rows);
  if(hdr>=0){
    const headers = rows[hdr].map(h=>String(h).toLowerCase());
    const teamCol = headers.findIndex(h=>h.includes('team'));
    const winsCol = headers.findIndex(h=>h.includes('win') && !h.includes('%'));
    const lossCol = headers.findIndex(h=>h.includes('loss'));
    const pfCol = headers.findIndex(h=>h.includes('points for')||h==='pf');
    const paCol = headers.findIndex(h=>h.includes('points against')||h==='pa');
    const pctCol = headers.findIndex(h=>h.includes('win %')||h.includes('win%')||h.includes('pct'));
    const out=[];
    for(let r=hdr+1;r<rows.length;r++){
      const t = rows[r][teamCol]||'';
      if(!t || String(t).trim()==='') break;
      out.push({
        team:String(t).trim(),
        wins:String(rows[r][winsCol]||'').trim(),
        losses:String(rows[r][lossCol]||'').trim(),
        pf:String(rows[r][pfCol]||'').trim(),
        pa:String(rows[r][paCol]||'').trim(),
        pct:String(rows[r][pctCol]||'').trim()
      });
    }
    return out;
  } else { 
    const accum = {};
    for(const r of rows){
      if(r.length<5) continue;
      const ta = String(r[1]||'').trim(); 
      const sa = parseFloat(String(r[2]||'').replace(/[^0-9\.\-]/g,''));
      const tb = String(r[3]||'').trim(); 
      const sb = parseFloat(String(r[4]||'').replace(/[^0-9\.\-]/g,''));
      if(!ta || !tb) continue;
      if(!accum[ta]) accum[ta] = {team:ta,w:0,l:0,pf:0,pa:0};
      if(!accum[tb]) accum[tb] = {team:tb,w:0,l:0,pf:0,pa:0};
      if(!isNaN(sa) && !isNaN(sb)){
        accum[ta].pf += sa; accum[ta].pa += sb;
        accum[tb].pf += sb; accum[tb].pa += sa;
        if(sa>sb){ accum[ta].w +=1; accum[tb].l +=1; }
        else if(sa<sb){ accum[tb].w +=1; accum[ta].l +=1; }
      }
    }
    return Object.values(accum).map(x=>({
      team:x.team,
      wins:x.w,
      losses:x.l,
      pf:x.pf,
      pa:x.pa,
      pct:(x.w+x.l)>0?Math.round((x.w/(x.w+x.l))*1000)/1000:''
    })).sort((a,b)=>b.wins-a.wins||b.pf-a.pf);
  }
}

function computeH2H(rows, teamOrder){
  const map = {}; const teams = teamOrder.slice();
  teams.forEach(t=> map[t] = {});
  for(const r of rows){
    if(r.length<5) continue;
    const ta = String(r[1]||'').trim(); 
    const sa = parseFloat(String(r[2]||'').replace(/[^0-9\.\-]/g,''));
    const tb = String(r[3]||'').trim(); 
    const sb = parseFloat(String(r[4]||'').replace(/[^0-9\.\-]/g,''));
    if(!ta || !tb) continue;
    if(!map[ta]) map[ta] = {}; 
    if(!map[tb]) map[tb] = {};
    if(!map[ta][tb]) map[ta][tb] = {w:0,l:0,t:0}; 
    if(!map[tb][ta]) map[tb][ta] = {w:0,l:0,t:0};
    if(!isNaN(sa) && !isNaN(sb)){ 
      if(sa>sb){ map[ta][tb].w +=1; map[tb][ta].l +=1; } 
      else if(sa<sb){ map[tb][ta].w +=1; map[ta][tb].l +=1; } 
      else { map[ta][tb].t +=1; map[tb][ta].t +=1; } 
    }
  }
  teams.forEach(a=> teams.forEach(b=> { if(!map[a][b]) map[a][b] = {w:0,l:0,t:0}; }));
  return {teams, map};
}

function renderStandings(standings){
  const container = document.getElementById('standings-area'); 
  container.innerHTML='';
  const tbl = document.createElement('table'); 
  tbl.className='standings-table';
  const thead = document.createElement('thead'); 
  thead.innerHTML = '<tr><th>Rank</th><th>Team</th><th>W</th><th>L</th><th>PF</th><th>PA</th><th>Win %</th></tr>'; 
  tbl.appendChild(thead);
  const tbody = document.createElement('tbody');
  standings.forEach((s,i)=>{
    const tr=document.createElement('tr'); 
    tr.innerHTML = '<td>'+ (i+1) + '</td><td><span class="team-label">'+ s.team + '</span></td><td>'+ s.wins + '</td><td>'+ s.losses + '</td><td>'+ s.pf + '</td><td>'+ s.pa + '</td><td>'+ s.pct + '</td>'; 
    tbody.appendChild(tr); 
  });
  tbl.appendChild(tbody); 
  container.appendChild(tbl);
}

function renderH2HTable(h2h){
  const container = document.getElementById('h2h-area'); 
  container.innerHTML='';
  const table = document.createElement('table'); 
  table.className='h2h-table';
  const header = document.createElement('tr'); 
  header.innerHTML = '<th></th>' + h2h.teams.map(function(t){return '<th>'+t+'</th>'}).join(''); 
  table.appendChild(header);
  h2h.teams.forEach(function(r){ 
    const tr = document.createElement('tr'); 
    tr.innerHTML = '<td><span class="team-label">'+ r + '</span></td>' + 
      h2h.teams.map(function(c){ 
        return '<td>' + (r===c?'-': (h2h.map[r] && h2h.map[r][c]? (h2h.map[r][c].w + '-' + h2h.map[r][c].l + (h2h.map[r][c].t? '-' + h2h.map[r][c].t : '')) : '0-0')) + '</td>'; 
      }).join(''); 
    table.appendChild(tr); 
  });
  container.appendChild(table);
}

function renderBracket(standings, seasonName, rows){
  const area = document.getElementById('bracket-area'); 
  area.innerHTML='';
  const year = parseInt(seasonName) || 0;
  const isEight = year >= 2022;
  const teams = standings.map(s=>s.team);
  const storageKey = 'bracket-' + seasonName;
  const initial = JSON.parse(localStorage.getItem(storageKey)||'null') || null;
  const wrap = document.createElement('div'); wrap.className='bracket-wrap';

  function rowDiv(aSelect,aScore,bSelect,bScore){
    const d=document.createElement('div'); 
    d.className='match-row'; 
    d.appendChild(aSelect); d.appendChild(aScore); 
    d.appendChild(document.createTextNode(' vs ')); 
    d.appendChild(bSelect); d.appendChild(bScore); 
    return d;
  }

  if(!isEight){
    const seed = teams.slice(0,6);
    const sf1 = (initial && initial.sf1) || {a:seed[0]||'', b:seed[3]||'', ascore:'', bscore:''};
    const sf2 = (initial && initial.sf2) || {a:seed[1]||'', b:seed[2]||'', ascore:'', bscore:''};
    const final = (initial && initial.final) || {a:'', b:'', ascore:'', bscore:''};
    const third = (initial && initial.third) || {a:'', b:'', ascore:'', bscore:''};
    const loser = (initial && initial.loser) || {a:seed[4]||'', b:seed[5]||'', ascore:'', bscore:''};

    function make(selVal){ 
      const s=document.createElement('select'); 
      s.className='team-select'; 
      const empty = document.createElement('option'); empty.value=''; empty.textContent='--'; 
      s.appendChild(empty); 
      seed.forEach(function(t){ 
        const o=document.createElement('option'); 
        o.value=t; o.textContent=t; 
        if(t===selVal) o.selected=true; 
        s.appendChild(o); 
      }); 
      return s; 
    }
    function score(v){ const i=document.createElement('input'); i.type='number'; i.className='score-input'; i.value = v||''; return i; }

    const sf1a = make(sf1.a), sf1as = score(sf1.ascore), sf1b = make(sf1.b), sf1bs = score(sf1.bscore);
    const sf2a = make(sf2.a), sf2as = score(sf2.ascore), sf2b = make(sf2.b), sf2bs = score(sf2.bscore);
    const finA = make(final.a), finAS = score(final.ascore), finB = make(final.b), finBS = score(final.bscore);
    const tA = make(third.a), tAs = score(third.ascore), tB = make(third.b), tBs = score(third.bscore);
    const lbA = make(loser.a), lbAs = score(loser.ascore), lbB = make(loser.b), lbBs = score(loser.bscore);

    const colS = document.createElement('div'); colS.className='bracket-col'; colS.innerHTML='<h3>Semifinals</h3>'; colS.appendChild(rowDiv(sf1a,sf1as,sf1b,sf1bs)); colS.appendChild(rowDiv(sf2a,sf2as,sf2b,sf2bs));
    const colF = document.createElement('div'); colF.className='bracket-col'; colF.innerHTML='<h3>Final</h3>'; colF.appendChild(rowDiv(finA,finAS,finB,finBS));
    const col3 = document.createElement('div'); col3.className='bracket-col'; col3.innerHTML='<h3>3rd Place</h3>'; col3.appendChild(rowDiv(tA,tAs,tB,tBs));
    const colL = document.createElement('div'); colL.className='bracket-col'; colL.innerHTML='<h3>Loser Bowl</h3>'; colL.appendChild(rowDiv(lbA,lbAs,lbB,lbBs));

    wrap.appendChild(colS); wrap.appendChild(colF); wrap.appendChild(col3); wrap.appendChild(colL);
    area.appendChild(wrap);

    function resolve(){
      const s1 = parseInt(sf1as.value)||0, s2 = parseInt(sf1bs.value)||0; const sf1win = (s1!==s2)?(s1>s2?sf1a.value:sf1b.value):'';
      const s3 = parseInt(sf2as.value)||0, s4 = parseInt(sf2bs.value)||0; const sf2win = (s3!==s4)?(s3>s4?sf2a.value:sf2b.value):'';
      if(finA.value !== sf1win) finA.value = sf1win || finA.value; 
      if(finB.value !== sf2win) finB.value = sf2win || finB.value;
      const fA = parseInt(finAS.value)||0, fB = parseInt(finBS.value)||0; const finalWin = (fA!==fB)?(fA>fB?finA.value:finB.value):'';
      const loser1 = sf1win===sf1a.value? sf1b.value : sf1a.value; 
      const loser2 = sf2win===sf2a.value? sf2b.value : sf2a.value;
      if(tA.value !== loser1) tA.value = loser1 || tA.value; 
      if(tB.value !== loser2) tB.value = loser2 || tB.value;

      const state = {
        sf1:{a:sf1a.value,b:sf1b.value,ascore:sf1as.value,bscore:sf1bs.value}, 
        sf2:{a:sf2a.value,b:sf2b.value,ascore:sf2as.value,bscore:sf2bs.value}, 
        final:{a:finA.value,b:finB.value,ascore:finAS.value,bscore:finBS.value}, 
        third:{a:tA.value,b:tB.value,ascore:tAs.value,bscore:tBs.value}, 
        loser:{a:lbA.value,b:lbB.value,ascore:lbAs.value,bscore:lbBs.value}
      };
      localStorage.setItem(storageKey, JSON.stringify(state));
    }
    [sf1a,sf1as,sf1b,sf1bs,sf2a,sf2as,sf2b,sf2bs,finA,finAS,finB,finBS,tA,tAs,tB,tBs,lbA,lbAs,lbB,lbBs].forEach(el=> el.addEventListener('input', resolve));
    resolve();
    return;
  }

  // (8-team branch unchanged – no syntax bug there)
  // ...
}

function renderAllTime(sheets){
  const years = Object.keys(sheets).filter(k=> k.toLowerCase()!=='all time');
  const out = [];
  years.forEach(y=>{
    const rows = sheets[y] || []; 
    const header = rows[0] ? rows[0].map(c=>String(c).toLowerCase()) : []; 
    let finalCol = header.findIndex(h=>h.includes('final')); 
    let found = ''; 
    if(finalCol>=0){ 
      for(let r=1;r<rows.length;r++) if(rows[r][finalCol] && String(rows[r][finalCol]).trim()!=='') found = rows[r][finalCol]; 
    } else { 
      const last = rows[rows.length-1] || []; found = last.slice(-1)[0] || ''; 
    } 
    const m = (String(found)||'').match(/(.*?)[\s:\-–]+([0-9]{1,3})/); 
    const champ = m ? m[1].trim() : (found||''); 
    out.push({year:y, champion: champ}); 
  });
  const el = document.getElementById('alltime-area'); 
  el.innerHTML=''; 
  const tbl = document.createElement('table'); 
  tbl.innerHTML = '<tr><th>Year</th><th>Champion</th></tr>' + out.map(o=>'<tr><td>'+o.year+'</td><td>'+o.champion+'</td></tr>').join(''); 
  el.appendChild(tbl);
}

async function init(){
  const sheets = await loadEmbeddedData();
  const seasonNames = Object.keys(sheets);
  const nav = document.getElementById('nav');
  nav.innerHTML = seasonNames.map(function(s){ return '<button class="nav-btn" data-season="'+s+'">'+s+'</button>' }).join(' ');
  document.querySelectorAll('.nav-btn').forEach(function(b){ 
    b.addEventListener('click', async function(e){ 
      const s = e.target.dataset.season; 
      document.getElementById('season-title').textContent = s; 
      const rows = sheets[s]; 
      const standings = extractStandings(rows); 
      renderStandings(standings); 
      const h2h = computeH2H(rows, standings.map(x=>x.team)); 
      renderH2HTable(h2h); 
      renderBracket(standings, s, rows); 
      if(s.toLowerCase()==='all time'){ renderAllTime(sheets); } else { document.getElementById('alltime-area').innerHTML=''; } 
    }); 
  });
  if(seasonNames.length>0){ document.querySelector('.nav-btn').click(); }
}
init();
document.getElementById('reset-bracket').addEventListener('click', function(){ 
  const s = document.getElementById('season-title').textContent; 
  localStorage.removeItem('bracket-'+s); 
  document.querySelector('.nav-btn[data-season="'+s+'"]').click(); 
});
</script>
</body>
</html>
