<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Between the Lines — Fantasy History</title>
<link rel="stylesheet" href="style.css">
</head>
<body>
<header>
  <h1>Between the Lines — Fantasy History</h1>
  <p class="subtitle">Standings, H2H, interactive bracket — data from embedded workbook</p>
</header>

<nav id="nav"></nav>

<main class="main">
  <section class="card" id="standings-card">
    <h2 id="season-title">Loading...</h2>
    <div id="standings-area"></div>
  </section>

  <section class="card" id="h2h-card">
    <h2>Head-to-Head</h2>
    <div id="h2h-area"></div>
  </section>

  <section class="card" id="bracket-card">
    <h2>Playoff Bracket (editable)</h2>
    <div id="bracket-area"></div>
    <div style="margin-top:8px"><button id="reset-bracket">Reset Bracket</button></div>
  </section>

  <section class="card" id="alltime-card">
    <h2>All-Time</h2>
    <div id="alltime-area"></div>
  </section>
</main>

<footer class="footer">Data source: embedded Excel snapshot. Bracket edits stored locally.</footer>

<script>
async function loadEmbeddedData() {
  const res = await fetch('data.json');
  return await res.json();
}

function findStandingsHeader(rows) {
  for (let r = 0; r < Math.min(10, rows.length); r++) {
    const lower = rows[r].map(c => String(c).toLowerCase());
    if (lower.some(c => c.includes('team')) && lower.some(c => c.includes('win'))) return r;
  }
  return -1;
}

function extractStandings(rows) {
  const hdr = findStandingsHeader(rows);
  if (hdr >= 0) {
    const headers = rows[hdr].map(h => String(h).toLowerCase());
    const teamCol = headers.findIndex(h => h.includes('team'));
    const winsCol = headers.findIndex(h => h.includes('win') && !h.includes('%'));
    const lossCol = headers.findIndex(h => h.includes('loss'));
    const pfCol = headers.findIndex(h => h.includes('points for') || h === 'pf');
    const paCol = headers.findIndex(h => h.includes('points against') || h === 'pa');
    const pctCol = headers.findIndex(h => h.includes('win %') || h.includes('pct'));
    const out = [];
    for (let r = hdr + 1; r < rows.length; r++) {
      const t = rows[r][teamCol] || '';
      if (!t || String(t).trim() === '') break;
      out.push({
        team: String(t).trim(),
        wins: String(rows[r][winsCol] || '').trim(),
        losses: String(rows[r][lossCol] || '').trim(),
        pf: String(rows[r][pfCol] || '').trim(),
        pa: String(rows[r][paCol] || '').trim(),
        pct: String(rows[r][pctCol] || '').trim()
      });
    }
    return out;
  } else {
    const accum = {};
    for (const r of rows) {
      if (r.length < 5) continue;
      const ta = String(r[1] || '').trim();
      const sa = parseFloat(String(r[2] || '').replace(/[^0-9.\-]/g, ''));
      const tb = String(r[3] || '').trim();
      const sb = parseFloat(String(r[4] || '').replace(/[^0-9.\-]/g, ''));
      if (!ta || !tb) continue;
      if (!accum[ta]) accum[ta] = { team: ta, w: 0, l: 0, pf: 0, pa: 0 };
      if (!accum[tb]) accum[tb] = { team: tb, w: 0, l: 0, pf: 0, pa: 0 };
      if (!isNaN(sa) && !isNaN(sb)) {
        accum[ta].pf += sa; accum[ta].pa += sb;
        accum[tb].pf += sb; accum[tb].pa += sa;
        if (sa > sb) { accum[ta].w += 1; accum[tb].l += 1; }
        else if (sa < sb) { accum[tb].w += 1; accum[ta].l += 1; }
      }
    }
    return Object.values(accum).map(x => ({
      team: x.team,
      wins: x.w,
      losses: x.l,
      pf: x.pf,
      pa: x.pa,
      pct: (x.w + x.l) > 0 ? Math.round((x.w / (x.w + x.l)) * 1000) / 1000 : ''
    })).sort((a, b) => b.wins - a.wins || b.pf - a.pf);
  }
}

function computeH2H(rows, teamOrder) {
  const map = {};
  const teams = teamOrder.slice();
  teams.forEach(t => map[t] = {});
  for (const r of rows) {
    if (r.length < 5) continue;
    const ta = String(r[1] || '').trim();
    const sa = parseFloat(String(r[2] || '').replace(/[^0-9.\-]/g, ''));
    const tb = String(r[3] || '').trim();
    const sb = parseFloat(String(r[4] || '').replace(/[^0-9.\-]/g, ''));
    if (!ta || !tb) continue;
    if (!map[ta][tb]) map[ta][tb] = { w: 0, l: 0, t: 0 };
    if (!map[tb][ta]) map[tb][ta] = { w: 0, l: 0, t: 0 };
    if (!isNaN(sa) && !isNaN(sb)) {
      if (sa > sb) { map[ta][tb].w++; map[tb][ta].l++; }
      else if (sa < sb) { map[tb][ta].w++; map[ta][tb].l++; }
      else { map[ta][tb].t++; map[tb][ta].t++; }
    }
  }
  teams.forEach(a => teams.forEach(b => { if (!map[a][b]) map[a][b] = { w: 0, l: 0, t: 0 }; }));
  return { teams, map };
}

function renderStandings(standings) {
  const container = document.getElementById('standings-area');
  container.innerHTML = '';
  const tbl = document.createElement('table');
  tbl.className = 'standings-table';
  const thead = document.createElement('thead');
  thead.innerHTML = '<tr><th>Rank</th><th>Team</th><th>W</th><th>L</th><th>PF</th><th>PA</th><th>Win %</th></tr>';
  tbl.appendChild(thead);
  const tbody = document.createElement('tbody');
  standings.forEach((s, i) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${i + 1}</td><td>${s.team}</td><td>${s.wins}</td><td>${s.losses}</td><td>${s.pf}</td><td>${s.pa}</td><td>${s.pct}</td>`;
    tbody.appendChild(tr);
  });
  tbl.appendChild(tbody);
  container.appendChild(tbl);
}

function renderH2HTable(h2h) {
  const container = document.getElementById('h2h-area');
  container.innerHTML = '';
  const table = document.createElement('table');
  table.className = 'h2h-table';
  const header = document.createElement('tr');
  header.innerHTML = '<th></th>' + h2h.teams.map(t => `<th>${t}</th>`).join('');
  table.appendChild(header);
  h2h.teams.forEach(r => {
    const tr = document.createElement('tr');
    tr.innerHTML = '<td>' + r + '</td>' +
      h2h.teams.map(c => r === c ? '<td>-</td>' :
        `<td>${h2h.map[r][c].w}-${h2h.map[r][c].l}</td>`).join('');
    table.appendChild(tr);
  });
  container.appendChild(table);
}

function renderAllTime(sheets) {
  const years = Object.keys(sheets).filter(k => k.toLowerCase() !== 'all time');
  const out = [];
  years.forEach(y => {
    const rows = sheets[y] || [];
    const champ = rows[1] ? rows[1][0] : '';
    out.push({ year: y, champion: champ });
  });
  const el = document.getElementById('alltime-area');
  el.innerHTML = '';
  const tbl = document.createElement('table');
  tbl.innerHTML = '<tr><th>Year</th><th>Champion</th></tr>' +
    out.map(o => `<tr><td>${o.year}</td><td>${o.champion}</td></tr>`).join('');
  el.appendChild(tbl);
}

async function init() {
  const sheets = await loadEmbeddedData();
  const seasonNames = Object.keys(sheets);
  const nav = document.getElementById('nav');
  nav.innerHTML = seasonNames.map(s => `<button class="nav-btn" data-season="${s}">${s}</button>`).join(' ');
  document.querySelectorAll('.nav-btn').forEach(b => {
    b.addEventListener('click', e => {
      const s = e.target.dataset.season;
      document.getElementById('season-title').textContent = s;
      const rows = sheets[s];
      const standings = extractStandings(rows);
      renderStandings(standings);
      const h2h = computeH2H(rows, standings.map(x => x.team));
      renderH2HTable(h2h);
      if (s.toLowerCase() === 'all time') {
        renderAllTime(sheets);
      } else {
        document.getElementById('alltime-area').innerHTML = '';
      }
    });
  });
  if (seasonNames.length > 0) document.querySelector('.nav-btn').click();
}

init();
</script>
</body>
</html>
